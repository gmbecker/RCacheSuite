% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cache.R
\name{evalWithCache}
\alias{evalWithCache}
\title{evalWithCache}
\usage{
evalWithCache(code, codeInfo, inputVars, outputVars,
  cache = cachingEngine(write_on_cache = TRUE), eval_fun = cache$eval_fun,
  return_handler = cache$return_handler, env = .GlobalEnv, force = FALSE,
  cacheRand = FALSE, verbose = FALSE, gexts = "png",
  gdev = sapply(gexts, function(nm) get(nm, mode = "function")),
  last = TRUE, stopMissingInput = FALSE, singleEntFun = sameOutVar,
  unCacheable = mustForce, ...)
}
\arguments{
\item{code}{The code to evaluate}

\item{codeInfo}{A ScriptNodeInfo object, defaults to the result of
calling \code{getInputs} on the \code{code} with default
handling options}

\item{inputVars}{A vector of variable names which are inputs to the
code block. Overrides automatically detected inputs}

\item{outputVars}{A vector of variable name which are outputs
generated by the code block. Overrides automatically detected
outputs}

\item{cache}{The CachingEngine to use when evaluating the
code. Defaults to an engine which writes caches out
immediately, mimicing caching behavior of other systems. See
note.}

\item{eval_fun}{A function to perform evaluation of the
code. Defaults to the code evaluator associated with
\code{cache}}

\item{return_handler}{A function to be called on the value returned
by evaluating the code (or loading from cache). Defaults to
return handler associated with \code{cache}}

\item{env}{The environment in which to evaluate the code or load
the cached outputs}

\item{force}{A logical indicating whether to force a cache
refresh. If \code{TRUE}, cached values will NOT be used, but a
new cache will be written after evaluating
\code{code}. Defaults to \code{FALSE}}

\item{cacheRand}{A logical indicating whether to create/use caches
for expressions with a detected random component. Defaults to
FALSE}

\item{verbose}{Should extra informative messages be
emitted. Defaults to \code{FALSE}}

\item{gexts}{A vector of graphics file extensions for caching
graphics}

\item{gdev}{A vector of graphics devices to use to generate the
files indicated by \code{gexts} for caching graphics. Defaults
to functions named directly for their extensions (e.g.,
\code{png}).}

\item{last}{logical. Is this the last expression in the codeblock
being evaluated. Passed to return handler. Generally this
should not be manually set.}

\item{stopMissingInput}{Should an error be thrown when an input
variable is not present in the evaluation scope. If
\code{FALSE} a warning will be emitted. Defaults to
\code{FALSE}}

\item{singleEntFun}{A function, or NULL. If a function, it is
called on \code{codeInfo} to determine if \code{code} should be
treated as a single entity for caching purposes. If
\code{NULL}, or a function that returns \code{FALSE},
expressions in \code{code} are evaluated and cached
separately. Defautls to \code{sameOutVar}}

\item{unCacheable}{A function which accepts a ScriptNodeInfo object
and returns a logical value indicating whether the computation
is cacheable. Defaults to \code{mustForce}}

\item{...}{Passed to \code{eval_fun} if \code{code} is evaluated.}
}
\value{
The value generated by \code{cache$return_handler} when
    called on the value returned by evaluating \code{code} using
    \code{cache$eval_fun}.

 In other words, the value
 \preformatted{
   cache$return_handler(cache$eval_fun(code, env, ...))
 }
 is returned, though if a valid cache is found,
 \code{cache$eval_fun} is not called and the cached return value (of the
 evaluator function at the time of caching) is
 passed to \code{cache$return_handler}.
 
 The return value of \code{cache$return_handler} is returned
 invisibly. The \code{cache$return_handler} function itself is
 responsible for the duplication of any side effects, including any
 printing of errors, warnings, or messages as well as any necessary
 regeneration of graphical output.
}
\description{
This function accepts a piece of R code and performs
    state (input variable value) dependent cached evaluation of it.
}
\details{
This function performs state-aware cached evaluation of R
    code. This means that a cache is considered to apply if and
    only if both the code (after parsing) and the values of any
    variables used as inputs to the code are identical to those
    present when the cache was created.

Cached evaluation is done via a caching engine (CachingEngine
object), which has a set of caches it already knows about, the
ability to create new caches, and a set of behaviors for when - if
ever - a cache should be written to disk, an evaluator function
which evaluates the code, and a return handler which processes the
object returned from the evaluator or loaded from a matching cache.

The evaluator function is charged with evaluating code and
capturing any side-effects of the code that the user wishes to
cache and recreate, encoding them in the object it returns. The
return handler is tasked with processing that return value,
recreating any side effects (including plots, messages printed to
the console, etc) and then returning the raw result of the
evaluation.
}
\examples{
\dontrun{
   res = evalWithCache("x = 5; y = x+7;y")
}
}
\seealso{
\code{\link{cachingEngine}}, \code{\link[CodeDepends]{getInputs}}
}
\author{
Gabriel Becker
}
